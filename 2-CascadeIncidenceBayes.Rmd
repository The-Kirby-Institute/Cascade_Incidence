HIV Cascade Incidence - Bayesian Approach
=========================================
  
This Rmarkdown script builds on the cascade incidence regression analysis and 
applies a Bayesian Melding approach. 

```{r initialization}
rm(list=ls()) 

# Source to current directory and set working directory
basePath <- getwd()

# Various directories
sampleTime <- "Million" # defined by user in %Y-%m-%d(%H-%M) 
                                  # format or some other name
sampleFolder <- file.path(basePath, "output", 
                         paste("CountAnalysis_", sampleTime, sep = ""))

dataFolder <- file.path(basePath, "data")
resultsFolder <- file.path(basePath, "output")
Rcode <- file.path(basePath, "code") 

# Load standard libraries, key functions and options
source(file.path(Rcode, "LoadLibrary.R"), echo = TRUE)
source(file.path(Rcode, "DataLibraries.R"), echo = TRUE)

# Source Useful functions
source(file.path(Rcode, "BayesFunctions.R"), echo = TRUE)

```

## Load previously created cascade samples 

```{r loaddata}
# Need to load previoulsy generated cascadeData
analysisYear <- 2014

# Input data 
inputFile <- paste("gbm_hiv_cascade-", toString(analysisYear), 
                   ".csv", sep = "")

# Load hivCascade data
hivCascade <- read.csv(file.path(resultsFolder, inputFile), as.is = c(2))

# Load new infections data 
newInfectionsFile <- file.path(dataFolder, "new_infections_gbm.csv")
newInfects <- read.csv(newInfectionsFile)

# Extract some useful numbers
numYears <- nrow(newInfects)
years <- newInfects$year

# Create a best estimate cascade
cascadeBest <- hivCascade[, 1:3] %>% 
  spread(stage, value) %>% 
  select(year, undiagnosed, diagnosed, unsuppressed, suppressed)

cascadeBest$infections <- newInfects$diagnoses

# Estimate error bounds - store information in a data frame for 
# ease of extraction when creating priors
errorRange <- hivCascade %>%
  filter(stage %in% c("undiagnosed", "diagnosed", "unsuppressed",
                      "suppressed")) %>%
  group_by(stage) %>%
  summarise(errlower = mean(lower/value),
            errupper = mean(upper/value))

```

## Bayesian melding approach

```{r bayessims}
# In this chunk we apply a Bayesian melding methodology by sampling from 
# priors and running the samples in our model. It takes some time
# time so it is set up to be optional.

# Chunk Options ----------------------------------------------------------

numBayesSamples <- 1e3 # number of prior samples

useSaved <- TRUE  # use previous set of sampled priors
saveSims <- FALSE   # save sample priors and weights

# Details of inputs if required
if (useSaved) {
  # Specify details of saved file
  simTime <- "2016-03-30(14-37)" # in %Y-%m-%d(%H-%M) format 
                                 # or some other name
  folder <- paste("CascadeBayes_", simTime, sep = "")
  inputFolder <- file.path(resultsFolder, folder)
  savedFile <- paste(simTime, "_CascadeBayes_Sims.rda", sep = "")
}

# Details of where to store outputs if desired
if (saveSims) {
  currTime <- format(Sys.time(), "%Y-%m-%d(%H-%M)") # to append to files
  folder <- paste("CascadeBayes_", currTime, sep="")
  
  # Create directory
  dir.create(file.path(resultsFolder,folder), showWarnings = FALSE)
  outputFolder <- file.path(resultsFolder, folder)
}

# Run analysis -----------------------------------------------------------

if (useSaved) {
  load(file.path(inputFolder, savedFile))
} else {
  # Set up priors --------------------------------------------------------
  
  # Priors for beta1, beta2, beta3, and beta4 - at this stage 
  # assume uniform priors except for beta4 <- f4 * beta2
  # Systematic error in the cascade stage estimates is included
  # The uniform range is given by a relative range compared to beta2 and 
  # the error range. 
  
  beta <- c(0.005, 0.06)
  
  beta1Rel <- c(0.9, 30)
  beta3Rel <- c(0.05, 5)
  
  errN1 <- as.numeric(errorRange[1, 2:3])
  errN2 <- as.numeric(errorRange[2, 2:3])
  errN3 <- as.numeric(errorRange[3, 2:3])
  errN4 <- as.numeric(errorRange[4, 2:3])
  
  beta1 <- runif(numBayesSamples, 
                 beta1Rel[1] * beta[1] * errN1[1], 
                 beta1Rel[2] * beta[2] * errN1[2]) 
  beta2 <- runif(numBayesSamples, 
                 beta[1] * errN2[1], 
                 beta[2] * errN2[2]) 
  beta3 <- runif(numBayesSamples, 
                 beta3Rel[1] * beta[1] * errN3[1], 
                 beta3Rel[2] * beta[2] * errN3[2])    

  f4 <- rbeta(numBayesSamples, 0.85, 10.76)   # beta fitted to data
  beta2extra <- runif(numBayesSamples, 
                 beta[1] * errN2[1] * errN4[1], 
                 beta[2] * errN2[2] * errN4[2])
  beta4 <- beta2 * f4
  
  # Run simulations ------------------------------------------------------
  
  # Initialize outputs
  incidenceMatrix <- matrix(0, numBayesSamples, numYears)
  weights <- rep(0, numBayesSamples)
  
  # Extract our incidence data we want to fit to
  infectionsData <- cascadeBest$infections
  
  # Loop through samples and calculate infections over time
  # This could take a long time so time it, keep track and save it
  
  tic <- proc.time()
  
  for (bayesSample in 1:numBayesSamples) {
    # Likely to take a while so let us know where we are up to
    if (bayesSample %% 1000 == 1) {
      print(bayesSample)
    }
    
    incidenceSample <- IncFunc(cascadeBest, 
                               beta1[bayesSample], beta2[bayesSample],
                               beta3[bayesSample], beta4[bayesSample])
    incidenceMatrix[bayesSample, ] <- incidenceSample
    
    # For each sample calculate the weights using the likelihood function
    trend <- coef(lm(incidenceSample ~ years))["years"]
    maxInc <- max(incidenceSample)
    minInc <- min(incidenceSample)

    if ((minInc < 400|| maxInc > 1000) || trend < 0) {
    # if (minInc < 400|| maxInc > 1000) {
      weights[bayesSample] <- 0
    } else {
      weights[bayesSample] <- WeightError(infectionsData,
        incidenceSample, 10) # 10% error in incidence
    }
  }
  
  toc <- proc.time() - tic
  
  # Save results and Bayes parameters
  if (saveSims){
    # Save the output
    save(numBayesSamples, beta1, beta2, beta3, beta4,
      incidenceMatrix, weights,
        file = file.path(outputFolder, paste(currTime, 
          "_CascadeBayes_Sims.rda", sep = "")))
  }
}

```

```{r bayesposteriors}
# Using the results from runsims resample with replacement to create 
# psoteriors

resamples <- 2000
useSaved <- TRUE
saveOutputs <- FALSE

if (useSaved) {
  # Specify details of saved file
  simTime <- "2016-03-30(14-37)" # in %Y-%m-%d(%H-%M) format 
                                 # or some other name
  folder <- paste("CascadeBayes_", simTime, sep = "")
  inputFolder <- file.path(resultsFolder, folder)
  savedFile <- paste(simTime, "_CascadeBayes_Results.rda", sep = "")
  
  # Load saved file
  load(file.path(inputFolder, savedFile))
} else {
  
  # Resample by weight with replacement -----------------------------------
  resampleIndices <- sample(1:numBayesSamples, resamples, prob = weights, 
                            replace = TRUE) 
  
  # Number unique paramter sets resampled - want this to be relatively
  # stable
  numUniques <- length(unique(resampleIndices))
  
  # Save final outputs for generating results ----------------------------
  if (saveOutputs){
    # Save the output
    save(numBayesSamples, beta1, beta2, beta3, beta4,
         incidenceMatrix, weights, resamples, resampleIndices, 
         file = file.path(outputFolder, paste(currTime, 
         "_CascadeBayes_Results.rda", sep = "")))
  }
}

```

```{r quickstats}
# Generate some quick stats and results

# Number unique paramter sets resampled
numUniques <- length(unique(resampleIndices))

# Best fitting parameter sets
bestFit <- GetMode(resampleIndices)

# What the best fit looks like
# betaBestRel <- c(f1[bestFit], 1, f3[bestFit], f4[bestFit])
betaBest <- c(beta1[bestFit], beta2[bestFit], beta3[bestFit],
              beta4[bestFit])
betaBestRel <- betaBest / betaBest[2]            

```

The following chunk generates some quick results for checking purposes. 
The main results and plots are generate in the 
3-CascadeIncidenceResults.Rmd Rmarkdown script. 

```{r quickresults}

# Incidence best 

hist(beta3[resampleIndices], breaks = 100) # posterior
hist(beta1, breaks = 100) # prior

apply(cascadeBest[, 2:5], 1, function(x) x * betaBest/sum(x * betaBest))
  
bayesInc <- IncFunc(cascadeBest, betaBest[1], betaBest[2], 
        betaBest[3], betaBest[4])


# Plot model fits and data -----------------------------------------------

source(file.path(Rcode,"PlotOptions.R"))
source(file.path(Rcode,"TidyLongitudinal.R"))

# Convert incidence Matrix into a long data frame
incidenceDF <- TidyLongitudinal(incidenceMatrix[resampleIndices, ], 2004)

# Plot best fit regression and Bayes fit
load(file.path(resultsFolder, "CountAnalysis_2016-03-29(16-09)", 
               "2016-03-29(16-09)_Cascade_Regression_Results.rda"))

lmBeta <- as.numeric(undetectAdjustAnalysis)
lmInc <- apply(cascadeBest[ ,2:5], 1, 
               function(x) sum(x *  lmBeta))

ggplot(data = cascadeBest, aes(x = year, y = infections)) +
  geom_point(colour = "black") + 
  geom_line(aes(y = bayesInc), colour = "red") + 
  geom_line(aes(y = lmInc), colour = "blue") +
  coord_cartesian(ylim = c(0, 1000)) + 
  plotOpts 

# Functions for plotting range in simulation outputs
rangeUpper <- function(x) {
  quantile(x, c(0.975))
}

rangeLower <- function(x) {
  quantile(x, c(0.025))
}

# Incidence results plot
simsPlot <- ggplot(data = incidenceDF, 
                   aes(x = year, y = value, group = sim)) +
  geom_line(colour = "grey") +
  geom_point(data = cascadeBest, aes(y = infections, group = 1), 
             colour = "black") + 
  stat_summary(aes(group = 1), geom = "line", fun.y = median) +
  stat_summary(aes(group = 1), geom = "line", 
               fun.y = rangeUpper, linetype = "dashed") + 
  stat_summary(aes(group = 1), geom = "line", 
               fun.y = rangeLower, linetype = "dashed") +
  geom_line(data = cascadeBest, aes(y = bayesInc, group = 1), 
            colour = "red") + 
  coord_cartesian(ylim = c(0, 1000)) + 
  plotOpts

simsPlot

# Parameter prior and posterior distributions -------------------------

priorFrame <- data.frame(beta1 = beta1,
                         beta2 = beta2,
                         beta3 = beta3,
                         beta4 = beta4)

posteriorFrame <- data.frame(beta1 = beta1[resampleIndices],
                             beta2 = beta2[resampleIndices],
                             beta3 = beta3[resampleIndices],
                             beta4 = beta4[resampleIndices])

parameterPlot("beta4", priorFrame, posteriorFrame)

```

