HIV Cascade Incidence - Bayesian Approach
=========================================
  
This Rmarkdown script builds on the cascade incidence regression analysis and 
applies a Bayesian Melding approach. 

```{r initialization}
rm(list=ls()) 

# Source to current directory and set working directory
basePath <- getwd()

# Various directories
sampleTime <- "Million" # defined by user in %Y-%m-%d(%H-%M) 
                                  # format or some other name
sampleFolder <- file.path(basePath, "output", 
                         paste("CountAnalysis_", sampleTime, sep = ""))

dataFolder <- file.path(basePath, "data")
resultsFolder <- file.path(basePath, "output")
Rcode <- file.path(basePath, "code") 

# Load standard libraries, key functions and options
source(file.path(Rcode, "LoadLibrary.R"), echo=TRUE)
source(file.path(Rcode, "DataLibraries.R"), echo=TRUE)

# Script parameters ------------------------------------------------------

# Options for running and saving things
useSubset <- TRUE # take a subset of our big sample of the cascade
if (useSubset) {
    subSamples <- 100000
}

# Useful functions --------------------------------------------------------

# Set up a function so we can eaily calculate the incidence values
# for each sample
incFunc <- function(data, beta1, beta2, beta3, beta4) {
  # Data is a data frame with the countSample data for each year
  # err represents the error adjustmengt for the inputs
  
  return(beta1 * data$undiag  + beta2 * data$diag  + 
         beta3 * data$unsuppressed  + beta4 * data$suppressed)
}

# Setup the likelihood function for calculating the weight

WeightError <- function(data, estimate, err) {
  nn <- length(data)
  x <- data - estimate # difference between observed and simulated
  
  sigma <- data * err/100 # standard deviation
  mu <- rep(0, nn) # mean of x is zero if same
  w <- prod(dnorm(x, mu, sigma) / dnorm(mu, mu, sigma))
  return(w)
}

```

## Load previously created cascade samples 

```{r loaddata}
# Need to load previoulsy generated cascadeData
analysisYear <- 2014

# Input data 
inputFile <- paste("gbm_hiv_cascade-", toString(analysisYear), 
                   ".csv", sep = "")

# Load hivCascade data
hivCascade <- read.csv(file.path(resultsFolder, inputFile), as.is = c(2))

# Load new infections data 
newInfectionsFile <- file.path(dataFolder, "new_infections_gbm.csv")
newInfects <- read.csv(newInfectionsFile)

# Extract some useful numbers
numYears <- nrow(newInfects)
years <- newInfects$year

# Create a best estimate cascade
cascadeBest <- hivCascade[, 1:3] %>% 
  spread(stage, value) %>% 
  select(year, undiagnosed, diagnosed, unsuppressed, suppressed)

cascadeBest$infections <- newInfects$diagnoses

# Estimate error bounds - store information in a data frame for 
# ease of extraction when creating priors
errorRange <- hivCascade %>%
  filter(stage %in% c("undiagnosed", "diagnosed", "unsuppressed",
                      "suppressed")) %>%
  group_by(stage) %>%
  summarise(errlower = mean(lower/value),
            errupper = mean(upper/value),
            start_lower = lower[1],
            start_upper = upper[1],
            rate_est = (tail(value, 1) - value[1]) / length(year),
            rate_lower = (tail(lower, 1) - upper[1]) / length(year),
            rate_upper = (tail(upper, 1) - lower[1]) / length(year))

```

## Bayesian melding approach

```{r bayessims}
# In this chunk we apply a Bayesian melding methodology by sampling from 
# priors and running the samples in our model. It takes some time
# time so it is set up to be optional.

# Chunk Options ----------------------------------------------------------

numBayesSamples <- 3e5 # number of prior samples

useSaved <- FALSE  # use previous set of sampled priors
saveSims <- FALSE   # save sample priors and weights
useError <- FALSE
errFull <- FALSE

# includeError <- FALSE

# Details of inputs if required
if (useSaved) {
  simTime <- "2016-03-29(16-39)" # in %Y-%m-%d(%H-%M) format 
                                 # or some other name
  folder <- paste("CascadeBayes_", simTime, sep = "")
  inputFolder <- file.path(resultsFolder, folder)
  savedFile <- paste(simTime, "_CascadeBayes.rda", sep = "")
}

# Details of where to store outputs if desired
if (saveSims) {
  currTime <- format(Sys.time(), "%Y-%m-%d(%H-%M)") # to append to files
  folder <- paste("CascadeBayes_", currTime, sep="")
  
  # Create directory
  dir.create(file.path(resultsFolder,folder), showWarnings = FALSE)
  outputFolder <- file.path(resultsFolder, folder)
}

# Run analysis -----------------------------------------------------------


if (useSaved) {
  load(file.path(inputFolder, savedFile))
} else {
  # Set up priors --------------------------------------------------------
  
  # Priors for beta1, beta2, beta3, and beta4 - at this stage 
  # assume uniform priors except for beta4 <- f4 * beta2
  # but we need to be more rigorous about this I think
  
  beta1 <- runif(numBayesSamples, 0.9 * 0.005, 30 * 0.06) # uniform 
  beta2 <- runif(numBayesSamples, 0.005, 0.06)            # uniform
  beta3 <- runif(numBayesSamples, 0.05 * 0.005, 5 * 0.06)    # uniform
  # f3 <- rep(1, numBayesSamples)
  f4 <- rbeta(numBayesSamples, 0.85, 10.76)   # beta fitted to data
  beta4 <- beta2 * f4
  
  
  # Priors for our error estimates if required
  # if (useError) {
  #   if (errFull) {
  #     # Unsure if this is necessary
  #   } else {
  #     # Use systematic estimates from error range 
  #     unDiagErr <- as.numeric(filter(errorRange, 
  #                                    stage == "undiagnosed")[2:3])
  #     diagErr <- as.numeric(filter(errorRange, 
  #                                  stage == "diagnosed")[2:3])
  #     unSuspressErr <- as.numeric(filter(errorRange, 
  #                                        stage == "unsuppressed")[2:3])
  #     suppressErr <- as.numeric(filter(errorRange, 
  #                                      stage == "suppressed")[2:3])
  #     
  #     # Convert to systematic errors
  #     errf1 <- runif(numBayesSamples, unDiagErr[1], unDiagErr[2]) # uniform
  #     errf2 <- runif(numBayesSamples, diagErr[1], diagErr[2]) # uniform
  #     errf3 <- runif(numBayesSamples, unSuspressErr[1], 
  #                    unSuspressErr[2]) # uniform
  #     errf4 <- runif(numBayesSamples, suppressErr[1], 
  #                    suppressErr[2]) # uniform
  #   }
  # } else {
  #   errf1 <- rep(1, numBayesSamples)
  #   errf2 <- errf1
  #   errf3 <- errf1
  #   errf4 <- errf1  
  # }
  
  
  # Run simulations ------------------------------------------------------
  
  # Initialize outputs
  incidenceMatrix <- matrix(0, numBayesSamples, numYears)
  weights <- rep(0, numBayesSamples)
  
  # Extract our incidence data we want to fit to
  infectionsData <- cascadeBest$infections
  
  # Loop through samples and calculate infections over time
  # This could take a long time so time it, keep track and save it
  
  tic <- proc.time()
  
  for (bayesSample in 1:numBayesSamples) {
    # Likely to take a while so let us know where we are up to
    if (bayesSample %% 1000 == 1) {
      print(bayesSample)
    }
    
    if (errFull) {
      # Create an error data frame to use instead
      
    } else {
      incidenceSample <- incFunc(cascadeBest, 
          beta1[bayesSample], beta2[bayesSample], beta3[bayesSample],
          beta4[bayesSample])
      incidenceMatrix[bayesSample, ] <- incidenceSample
    }
    
    # For each sample calculate the weights using the likelihood function
    # trend <- coef(lm(incidenceSample ~ years))["years"]
    maxInc <- max(incidenceSample)
    minInc <- min(incidenceSample)

    # if ((minInc < 400|| maxInc > 1000) || trend < 0) {
    if (minInc < 400|| maxInc > 1000) {
      weights[bayesSample] <- 0
    } else {
      weights[bayesSample] <- WeightError(infectionsData,
        incidenceSample, 10) # 10% error in incidence
    }
    
  }
  
  toc <- proc.time() - tic
  
  # Save results and Bayes parameters
  if (saveSims){
    # Save the output
    save(numBayesSamples, f1, f3, f4, beta,
      incidenceMatrix, weights,
        file = file.path(outputFolder, paste(currTime, 
          "_CascadeBayes.rda", sep = "")))
  }
}

```

```{r bayesposteriors}
# Using the results from runsims resample with replacement to create 
# psoteriors

resamples <- 30000

# Resample by weight with replacement -------------------------------------
resampleIndices <- sample(1:numBayesSamples, resamples, prob = weights, 
                          replace = TRUE) 

# Generate some stats -----------------------------------------------------

# Need a function for mode! - 
getmode <- function(vector) {
  uniqueElements <- unique(vector)
  uniqueElements[which.max(tabulate(match(vector, uniqueElements)))]
}

# Number unique paramter sets resampled
numUniques <- length(unique(resampleIndices))

# Best fitting parameter sets
bestFit <- getmode(resampleIndices)

# What the best fit looks like
# betaBestRel <- c(f1[bestFit], 1, f3[bestFit], f4[bestFit])
betaBest <- c(beta1[bestFit], beta2[bestFit], beta3[bestFit],
              beta4[bestFit])
betaBestRel <- betaBest / betaBest[2]            
              

# if (useError) {
#   errBest <- c(errf1[bestFit], errf2[bestFit], errf3[bestFit],
#                errf4[bestFit])
# } else {
#   errBest <- c(1, 1, 1, 1)
# }

```

Generate some 

```{r quickresults}
# Incidence best 

hist(beta4[resampleIndices], breaks = 100)
hist(beta1, breaks = 100)

apply(cascadeBest[, 2:5], 1, function(x) x * betaBest/sum(x * betaBest))

# if (useError) {
#   errorBest <- errBest
# } else {
#   errorBest <- c(1, 1, 1, 1)
# }
  
bayesInc <- incFunc(cascadeBest, betaBest[1], betaBest[2], 
        betaBest[3], betaBest[4])

cascadeBest$infections

# Results from regression analysis for comparison
analysisResults <- "2016-03-29(16-09)"
load(file.path(resultsFolder, 
               paste("CountAnalysis_", analysisResults, sep = ""),
               paste(analysisResults, 
                     "_Cascade_Regression_Results.rda", sep = "")))


# lmBeta <- as.numeric(undetectAdjustAnalysis)
lmBeta <- as.numeric(undetectAdjustAnalysis)
lmBeta/lmBeta[2]

lmInc <- incFunc(cascadeBest, lmBeta[1], lmBeta[2], 
        lmBeta[3], lmBeta[4])

# A quick plot comparison
source(file.path(Rcode,"PlotOptions.R"))
source(file.path(Rcode,"TidyLongitudinal.R"))
LoadLibrary(quantreg)

rangeUppper <- function(x) {
  quantile(x, c(0.975))
}

rangeLower <- function(x) {
  quantile(x, c(0.025))
}

# incidenceDF <- as.data.frame(incidenceMatrix[resampleIndices, ])
incidenceDF <- TidyLongitudinal(incidenceMatrix[resampleIndices, ], 2004)

ggplot(data = cascadeBest, aes(x = year, y = infections)) +
  # geom_line(data = incidenceDF, 
  #           aes(x = year, y = value, group = sim), colour = "grey") +
  geom_point(colour = "black") + 
  geom_line(aes(y = bayesInc), colour = "red") + 
  # stat_summary(data = incidenceDF, aes(x = year, y = value, group = 1), 
  #              geom = "line", fun.y = median) + 
  coord_cartesian(ylim = c(0, 1500)) + 
  plotOpts 


simsPlot <- ggplot(data = incidenceDF, 
                   aes(x = year, y = value, group = sim)) +
  geom_line(colour = "grey") +
  geom_point(data = cascadeBest, aes(y = infections, group = 1), 
             colour = "black") + 
  stat_summary(aes(group = 1), geom = "line", fun.y = median) +
  stat_summary(aes(group = 1), geom = "line", fun.y = r95)


```

```{r quickplot}

priorFrame <- data.frame(beta1 = beta1,
                         beta2 = beta2,
                         beta3 = beta3,
                         beta4 = beta4)

posteriorFrame <- data.frame(beta1 = beta1[resampleIndices],
                             beta2 = beta2[resampleIndices],
                             beta3 = beta3[resampleIndices],
                             beta4 = beta4[resampleIndices])

ggplot(data = posteriorFrame, aes(x = beta4)) +
  geom_histogram(aes(y = (..count..)/sum(..count..)),
                     data = priorFrame,
                 binwidth = diff(range(beta4))/100) +
  geom_histogram(aes(y = (..count..)/sum(..count..)),
                     binwidth = diff(range(beta4))/100, alpha = 0.2) +
  coord_cartesian(xlim = range(beta4)) +
  ylab("Percent of simulations")

```
