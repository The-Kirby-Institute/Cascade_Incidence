HIV Cascade Incidence - Bayesian Approach
=========================================
  
This Rmarkdown script builds on the cascade incidence regression analysis and 
applies a Bayesian Melding approach. 

```{r initialization}
rm(list=ls()) 

# Source to current directory and set working directory
basePath <- getwd()

# Various directories
sampleTime <- "Million" # defined by user in %Y-%m-%d(%H-%M) 
                                  # format or some other name
sampleFolder <- file.path(basePath, "output", 
                         paste("CountAnalysis_", sampleTime, sep = ""))

dataFolder <- file.path(basePath, "data")
resultsFolder <- file.path(basePath, "output")
Rcode <- file.path(basePath, "code") 

# Load standard libraries, key functions and options
source(file.path(Rcode, "LoadLibrary.R"), echo=TRUE)
source(file.path(Rcode, "DataLibraries.R"), echo=TRUE)

# Script parameters ------------------------------------------------------

# Options for running and saving things
useSubset <- TRUE # take a subset of our big sample of the cascade
if (useSubset) {
    subSamples <- 100000
}

# Useful functions --------------------------------------------------------

# Set up a function so we can eaily calculate the incidence values
# for each sample
incFunc <- function(data, beta, f1, f3, f4, err = c(1, 1, 1, 1)) {
  # Data is a data frame with the countSample data for each year
  # err represents the error adjustmengt for the inputs
  
  return(beta * (f1 * data$undiag * err[1] + 
                   data$diag * err[2] + 
                   f3 * data$unsuppressed * err[3] + 
                   f4 * data$suppressed * err[4]))
}

# Setup the likelihood function for calculating the weight

WeightError <- function(data, estimate, err) {
  nn <- length(data)
  x <- data - estimate # difference between observed and simulated
  
  sigma <- data * err/100 # standard deviation
  mu <- rep(0, nn) # mean of x is zero if same
  w <- prod(dnorm(x, mu, sigma) / dnorm(mu, mu, sigma))
  return(w)
}

```

## Load previously created cascade samples 

```{r loaddata}
# Need to load previoulsy generated cascadeData
analysisYear <- 2014

# Input data 
inputFile <- paste("gbm_hiv_cascade-", toString(analysisYear), 
                   ".csv", sep = "")

# Load hivCascade data
hivCascade <- read.csv(file.path(resultsFolder, inputFile), as.is = c(2))

# Load new infections data 
newInfectionsFile <- file.path(dataFolder, "new_infections_gbm.csv")
newInfects <- read.csv(newInfectionsFile)

# Extract some useful numbers
numYears <- nrow(newInfects)
years <- newInfects$year

# Create a best estimate cascade
cascadeBest <- hivCascade[, 1:3] %>% 
  spread(stage, value) %>% 
  select(year, undiagnosed, diagnosed, unsuppressed, suppressed)

cascadeBest$infections <- newInfects$diagnoses

# Estimate error bounds - store information in a data frame for 
# ease of extraction when creating priors
errorRange <- hivCascade %>%
  filter(stage %in% c("undiagnosed", "diagnosed", "unsuppressed",
                      "suppressed")) %>%
  group_by(stage) %>%
  summarise(errlower = mean(lower/value),
            errupper = mean(upper/value),
            start_lower = lower[1],
            start_upper = upper[1],
            rate_est = (tail(value, 1) - value[1]) / length(year),
            rate_lower = (tail(lower, 1) - upper[1]) / length(year),
            rate_upper = (tail(upper, 1) - lower[1]) / length(year))

```

## Bayesian melding approach

```{r bayessims}
# In this chunk we apply a Bayesian melding methodology by sampling from 
# priors and running the samples in our model. It takes a long 
# time so it is set up to be optional.

# Chunk Options ----------------------------------------------------------

numBayesSamples <- 5e5 # number of prior samples

useSaved <- FALSE  # use previous set of sampled priors
saveSims <- TRUE   # save sample priors and weights
useError <- TRUE
errFull <- FALSE

# includeError <- FALSE

# Details of inputs if required
if (useSaved) {
  simTime <- "2016-03-29(16-39)" # in %Y-%m-%d(%H-%M) format 
                                 # or some other name
  folder <- paste("CascadeBayes_", simTime, sep = "")
  inputFolder <- file.path(resultsFolder, folder)
  savedFile <- paste(simTime, "_CascadeBayes.rda", sep = "")
}

# Details of where to store outputs if desired
if (saveSims) {
  currTime <- format(Sys.time(), "%Y-%m-%d(%H-%M)") # to append to files
  folder <- paste("CascadeBayes_", currTime, sep="")
  
  # Create directory
  dir.create(file.path(resultsFolder,folder), showWarnings = FALSE)
  outputFolder <- file.path(resultsFolder, folder)
}

# Run analysis -----------------------------------------------------------

# We slightly recast the equation to make it easier for setting up 
# the priors. 
# I = beta * (f1 * N1 + f2 * N2 + f2 * N3 + f4 * N4) 
# Generally we set f2 = 1 so we still have an equation with four 
# parameters.

if (useSaved) {
  load(file.path(inputFolder, savedFile))
} else {
  # Set up priors --------------------------------------------------------
  
  # Priors for f1, f3, f4, and beta - at this stage assume uniform priors
  # but we need to be more rigorous about this I think
  
  f1 <- runif(numBayesSamples, 0.9, 30)        # uniform 
  f3 <- runif(numBayesSamples, 0.5, 1.5)      # uniform
  f4 <- rbeta(numBayesSamples, 0.85, 10.76)   # beta fitted to data
  beta <- runif(numBayesSamples, 0.02, 0.15)   # uniform: need to 
                                              # recalculate
  
  # Priors for our error estimates if required
  if (useError) {
    if (errFull) {
      # Unsure if this is necessary
    } else {
      # Use systematic estimates from error range 
      unDiagErr <- as.numeric(filter(errorRange, 
                                     stage == "undiagnosed")[2:3])
      diagErr <- as.numeric(filter(errorRange, 
                                   stage == "diagnosed")[2:3])
      unSuspressErr <- as.numeric(filter(errorRange, 
                                         stage == "unsuppressed")[2:3])
      suppressErr <- as.numeric(filter(errorRange, 
                                       stage == "suppressed")[2:3])
      
      # Convert to systematic errors
      errf1 <- runif(numBayesSamples, unDiagErr[1], unDiagErr[2]) # uniform
      errf2 <- runif(numBayesSamples, diagErr[1], diagErr[2]) # uniform
      errf3 <- runif(numBayesSamples, unSuspressErr[1], 
                     unSuspressErr[2]) # uniform
      errf4 <- runif(numBayesSamples, suppressErr[1], 
                     suppressErr[2]) # uniform
    }
  } else {
    errf1 <- rep(1, numBayesSamples)
    errf2 <- errf1
    errf3 <- errf1
    errf4 <- errf1  
  }
  
  
  # Run simulations ------------------------------------------------------
  
  # Initialize outputs
  incidenceMatrix <- matrix(0, numBayesSamples, numYears)
  weights <- rep(0, numBayesSamples)
  
  # Extract our incidence data we want to fit to
  infectionsData <- cascadeBest$infections
  
  # Loop through samples and calculate infections over time
  # This could take a long time so time it, keep track and save it
  
  tic <- proc.time()
  
  for (bayesSample in 1:numBayesSamples) {
    # Likely to take a while so let us know where we are up to
    if (bayesSample %% 1000 == 1) {
      print(bayesSample)
    }
    
    if (errFull) {
      # Create an error data frame to use instead
      
    } else {
      incidenceSample <- incFunc(cascadeBest, 
          beta[bayesSample], f1[bayesSample], f3[bayesSample],
          f4[bayesSample], 
          err = c(errf1[bayesSample], errf2[bayesSample],
                  errf3[bayesSample], errf4[bayesSample]))
      incidenceMatrix[bayesSample, ] <- incidenceSample
    }
    
    # For each sample calculate the weights using the likelihood function
    # trend <- coef(lm(incidenceSample ~ years))["years"]
    maxInc <- max(incidenceSample)
    minInc <- min(incidenceSample)

    # if ((minInc < 400|| maxInc > 1000) || trend < 0) {
    if (minInc < 400|| maxInc > 1000) {
      weights[bayesSample] <- 0
    } else {
      weights[bayesSample] <- WeightError(infectionsData,
        incidenceSample, 10) # 10% error in incidence
    }
    
  }
  
  toc <- proc.time() - tic
  
  # Save results and Bayes parameters
  if (saveSims){
    # Save the output
    save(numBayesSamples, f1, f3, f4, beta,
      incidenceMatrix, weights,
        file = file.path(outputFolder, paste(currTime, 
          "_CascadeBayes.rda", sep = "")))
  }
}

```

```{r bayesposteriors}
# Using the results from runsims resample with replacement to create 
# psoteriors

resamples <- 100000

# Resample by weight with replacement -------------------------------------
resampleIndices <- sample(1:numBayesSamples, resamples, prob = weights, 
                          replace = TRUE) 

# Generate some stats -----------------------------------------------------

# Need a function for mode! - 
getmode <- function(vector) {
  uniqueElements <- unique(vector)
  uniqueElements[which.max(tabulate(match(vector, uniqueElements)))]
}

# Number unique paramter sets resampled
numUniques <- length(unique(resampleIndices))

# Best fitting parameter sets
bestFit <- getmode(resampleIndices)

# What the best fit looks like
betaBestRel <- c(f1[bestFit], 1, f3[bestFit], f4[bestFit])
betaBest <- beta[bestFit] * betaBestRel

if (useError) {
  errBest <- c(errf1[bestFit], errf2[bestFit], errf3[bestFit],
               errf4[bestFit])
} else {
  errBest <- c(1, 1, 1, 1)
}

```

Generate some 

```{r quickresults}
# Incidence best 

hist(errf1[resampleIndices], breaks = 1000)

apply(cascadeBest[, 2:5], 1, function(x) x * betaBest/sum(x * betaBest))

if (useError) {
  errorBest <- errBest
} else {
  errorBest <- c(1, 1, 1, 1)
}
  

bayesInc <- incFunc(cascadeBest, betaBest[2], betaBestRel[1], 
        betaBestRel[3], betaBestRel[4], err = errorBest)

cascadeBest$infections

# Results from regression analysis for comparison
analysisResults <- "2016-03-29(16-09)"
load(file.path(resultsFolder, 
               paste("CountAnalysis_", analysisResults, sep = ""),
               paste(analysisResults, 
                     "_Cascade_Regression_Results.rda", sep = "")))


# lmBeta <- as.numeric(undetectAdjustAnalysis)
lmBeta <- as.numeric(undetectAdjustAnalysis)
lmBeta/lmBeta[2]

lmInc <- incFunc(cascadeBest, lmBeta[2], lmBeta[1] / lmBeta[2], 
        lmBeta[3] / lmBeta[2], lmBeta[4] / lmBeta[2])

# A quick plot comparison
ggplot(data = cascadeBest, aes(x = year, y = infections)) +
  geom_point() + 
  geom_line(aes(y = lmInc)) + 
  geom_line(aes(y = bayesInc)) + 
  coord_cartesian(ylim = c(0, 1500)) + 
  theme_bw() 


```

```{r quickplot}

priorFrame <- data.frame(beta = beta,
                         f1 = f1,
                         f3 = f3,
                         f4 = f4)

posteriorFrame <- data.frame(beta = beta[resampleIndices],
                         f1 = f1[resampleIndices],
                         f3 = f3[resampleIndices],
                         f4 = f4[resampleIndices])

ggplot(data = posteriorFrame, aes(x = f4)) +
  geom_histogram(aes(y = (..count..)/sum(..count..)),
                     data = priorFrame,
                 binwidth = diff(range(f4))/100) +
  geom_histogram(aes(y = (..count..)/sum(..count..)),
                     binwidth = diff(range(f4))/100, alpha = 0.2) +
  coord_cartesian(xlim = range(f4)) +
  ylab("Percent of simulations")

```
