HIV Cascade Incidence - Bayesian Approach
=========================================
  
This Rmarkdown script builds on the cascade incidence regression analysis 
and applies a Bayesian Melding approach. Note it is designed for the
chunks to be run independently. Running the whole script in on go could
produce errors.

```{r initialization}
rm(list = ls()) 

# Source to current directory and set working directory
basePath <- getwd()

# Various directories
dataFolder <- file.path(basePath, "data")
resultsFolder <- file.path(basePath, "output")
Rcode <- file.path(basePath, "code") 

# Load standard libraries, key functions and options
source(file.path(Rcode, "LoadLibrary.R"), echo = TRUE)
source(file.path(Rcode, "DataLibraries.R"), echo = TRUE)

# Additional packages for exploring f4 distribution
LoadLibrary(triangle)
LoadLibrary(EnvStats)

# Source useful functions
source(file.path(Rcode, "BayesFunctions.R"), echo = TRUE)

```

## Load previously created cascade samples 

```{r loaddata}
# Need to load previoulsy generated cascadeData
analysisYear <- 2014

# Input data 
inputFileTag <- "ecdc"
inputFile <- paste("gbm_hiv_cascade-", toString(analysisYear), "_",
                   inputFileTag, ".csv", sep = "")

# Load hivCascade data
hivCascade <- read.csv(file.path(resultsFolder, inputFile), as.is = c(2))

# Load new infections data 
newInfectionsFile <- file.path(dataFolder, "new_infections_gbm.csv")
newInfects <- read.csv(newInfectionsFile)

# Extract some useful numbers
numYears <- nrow(newInfects)
years <- newInfects$year

# Create a best estimate cascade
cascadeBest <- hivCascade[, 1:3] %>% 
  spread(stage, value) %>% 
  select(year, undiagnosed, diagnosed, unsuppressed, suppressed)

cascadeBest$diagnoses <- newInfects$diagnoses
cascadeBest$infections <- newInfects$diagnoses_exclude_os # infections

# Estimate error bounds - store information in a data frame for 
# ease of extraction when creating priors
errorRange <- hivCascade %>%
  filter(stage %in% c("undiagnosed", "diagnosed", "unsuppressed",
                      "suppressed")) %>%
  group_by(stage) %>%
  summarise(errlower = mean(lower/value),
            errupper = mean(upper/value))

```

## Bayesian melding approach

```{r bayessims}
# In this chunk we apply a Bayesian melding methodology by sampling from 
# priors and running the samples in our model. It takes some time
# so it is set up to be optional.

# Chunk Options ----------------------------------------------------------

numBayesSamples <- 5e4 # number of prior samples
priorApproach <- "relative" # independent or relative

useSaved <- FALSE  # use previous set of sampled priors
saveSims <- FALSE   # save sample priors and weights
fileTag <- "ecdc"

# Specify f4 prior 
f4Prior <- SuppressedOption("option6")

priorWeight <- TRUE
priorWeightValues <- c(500, 1300, -1000) # c(400. 1100, 0)
# cascadeError <- TRUE


incidenceWeight <- seq(10, 10, length = numYears) 

# Details of inputs if required ------------------------------------------
if (useSaved) {
  # Specify details of saved file
  currTime <- "2016-04-14(13-32)" # in %Y-%m-%d(%H-%M) format 
                                   # or some other name
  folder <- paste("Cascade_Bayes_", currTime, sep = "")
  outputFolder <- file.path(resultsFolder, folder)
  savedFile <- paste(currTime, "_Cascade_Bayes_Sims_", fileTag,
                     ".rda", sep = "")
}

# Details of where to store outputs if desired
if (saveSims) {
  currTime <- format(Sys.time(), "%Y-%m-%d(%H-%M)") # to append to files
  folder <- paste("Cascade_Bayes_", currTime, sep="")
  
  # Create directory
  dir.create(file.path(resultsFolder,folder), showWarnings = FALSE)
  outputFolder <- file.path(resultsFolder, folder)
}

# Run analysis -----------------------------------------------------------

if (useSaved) {
  load(file.path(outputFolder, savedFile))
} else {
  # Set up priors --------------------------------------------------------
  
  # Priors for beta1, beta2, beta3, and beta4 - at this stage 
  # assume uniform priors except for beta4 <- f4 * beta2
  # Systematic error in the cascade stage estimates is included.
  # The uniform range is given by a relative range compared to beta2 and 
  # the error range. 
  
  # Specify min and max for error ranges in cascade estimates
  errN1 <- as.numeric(errorRange[1, 2:3])
  errN2 <- as.numeric(errorRange[2, 2:3])
  errN3 <- as.numeric(errorRange[3, 2:3])
  errN4 <- as.numeric(errorRange[4, 2:3])
  
  # Specify some common info for the beta values
  betaRange <- c(0.005, 0.06)
  beta1Rel <- c(0.9, 30)
  beta3Rel <- c(0.05, 5)
  
  if (priorApproach == "independent") {
    # Specify uniform priors between min and max
    beta1 <- runif(numBayesSamples, 
                   beta1Rel[1] * betaRange[1] * errN1[1], 
                   beta1Rel[2] * betaRange[2] * errN1[2]) 
    beta2 <- runif(numBayesSamples, 
                   betaRange[1] * errN2[1], 
                   betaRange[2] * errN2[2]) 
    beta3 <- runif(numBayesSamples, 
                   beta3Rel[1] * betaRange[1] * errN3[1], 
                   beta3Rel[2] * betaRange[2] * errN3[2])   
    
    # Calculate multiplicative factor (f) values
    beta <- beta2
    f1 <- beta1 / beta2
    f2 <- beta2 / beta2
    f3 <- beta3 / beta2
    
  } else if(priorApproach == "relative") {
    # Set up beta prior
    beta <- PriorSample(numBayesSamples, "unif", 
                        c(betaRange[1], betaRange[2])) 
      
    # Set up priors for multiplicative factors
    f1 <-PriorSample(numBayesSamples, "unif", 
                     c(beta1Rel[1], beta1Rel[2]))* 
      runif(numBayesSamples, errN1[1], errN1[2])
    
    f2 <- runif(numBayesSamples, errN2[1], errN2[2]) # just the error
    
    f3 <-PriorSample(numBayesSamples, "unif",
                     c(beta3Rel[1], beta3Rel[2])) * 
      runif(numBayesSamples, errN3[1], errN3[2])
    
    # Calculate corresponding beta values
    beta1 <- f1 * beta
    beta2 <- f2 * beta
    beta3 <- f3 * beta
  
  } else {
    stop("Unspecified approach to generating priors")
  }
  
  # Create f4 prior -- always relative to beta2
  f4 <- PriorSample(numBayesSamples, f4Prior$dist, f4Prior$params) * 
    runif(numBayesSamples, errN4[1], errN4[2])
  
  # Calculate corresponding beta 4 values
  beta4 <- beta * f4
  
  # Run simulations ------------------------------------------------------
  
  # Initialize outputs
  incidenceMatrix <- matrix(0, numBayesSamples, numYears)
  weights <- rep(0, numBayesSamples)
  
  # Extract our incidence data we want to fit to
  infectionsData <- cascadeBest$infections
  
  # Loop through samples and calculate infections over time
  # This could take a long time so time it, keep track and save it
  
  tic <- proc.time()
  
  for (bayesSample in 1:numBayesSamples) {
    # Likely to take a while so let us know where we are up to
    if (bayesSample %% 1000 == 1) {
      print(bayesSample)
    }
    
    incidenceSample <- IncFunc(cascadeBest,
                               beta1[bayesSample], beta2[bayesSample],
                               beta3[bayesSample], beta4[bayesSample])
    incidenceMatrix[bayesSample, ] <- incidenceSample
    
    # For each sample calculate the weights using the likelihood function
    trend <- coef(lm(incidenceSample ~ years))["years"]
    maxInc <- max(incidenceSample)
    minInc <- min(incidenceSample)

    if (priorWeight) {
      if ((minInc < priorWeightValues[1] || 
            maxInc > priorWeightValues[2]) || 
            trend < priorWeightValues[3]) {
        weights[bayesSample] <- 0
      } else {
        # 10% error in incidence
        weights[bayesSample] <- WeightError(infectionsData,
                                            incidenceSample, 
                                            incidenceWeight) 
      }
    } else {
      weights[bayesSample] <- WeightError(infectionsData,
        incidenceSample, 10) # 10% error in incidence
    }
  }
  
  toc <- proc.time() - tic
  
  # Save results and Bayes parameters
  if (saveSims){
    # Save the output
    save(numBayesSamples, priorApproach, f4Prior,
         beta, beta1, beta2, beta3, beta4, 
         f1, f2, f3, f4, incidenceMatrix, weights,
         file = file.path(outputFolder, paste(currTime, 
          "_Cascade_Bayes_Sims_", fileTag,".rda", sep = "")))
  }
}

```

```{r bayesposteriors}
# Using the results from runsims resample with replacement to create 
# psoteriors

resamples <- 20000
useSaved <- TRUE
saveOutputs <- FALSE

if (useSaved) {
  # Specify details of saved file
  fileTag <- "count"
  
  simTime <- "2016-04-14(11-10)" # in %Y-%m-%d(%H-%M) format 
                                  # or some other name
  folder <- paste("Cascade_Bayes_", simTime, sep = "")
  inputFolder <- file.path(resultsFolder, folder)
  savedFile <- paste(simTime, "_Cascade_Bayes_Results_", fileTag,
                     ".rda", sep = "")
  
  # Load saved file
  load(file.path(inputFolder, savedFile))
} else {
  
  # Resample by weight with replacement ----------------------------------
  resampleIndices <- sample(1:numBayesSamples, resamples, prob = weights, 
                            replace = TRUE) 
  
  # Number unique paramter sets resampled - want this to be relatively
  # stable
  numUniques <- length(unique(resampleIndices))
  
  # Save final outputs for generating results ----------------------------
  if (saveOutputs){
    # Save the output
    cascadeBestBayes <- cascadeBest
    save(cascadeBestBayes, numBayesSamples, priorApproach, f4Prior,
         beta, beta1, beta2, beta3, beta4, f1, f2, f3, f4,
         incidenceMatrix, weights, resamples, resampleIndices, 
         file = file.path(outputFolder, paste(currTime, 
         "_Cascade_Bayes_Results_", fileTag, ".rda", sep = "")))
  }
}

```

The following chunk generates some quick results for checking purposes. 
The main results and plots are generate in the 
3-CascadeIncidenceResults.Rmd Rmarkdown script. 

```{r quickresults}

# Generate some quick stats ----------------------------------------------

# Best fitting parameter sets
bestFit <- GetMode(resampleIndices)

# What the best fit looks like
# betaBestRel <- c(f1[bestFit], 1, f3[bestFit], f4[bestFit])
betaBest <- c(beta1[bestFit], beta2[bestFit], beta3[bestFit],
              beta4[bestFit])
betaBestRel <- betaBest / betaBest[2]   

# General exploration ----------------------------------------------------

hist(beta4[resampleIndices], breaks = 100) # posterior
hist(beta4, breaks = 100) # prior

hist(f4[resampleIndices], breaks = 100) # posterior
hist(f4, breaks = 100) # prior

# Proportion infections for each stage for betaBest

cascadeData <- select(cascadeBest, undiagnosed, diagnosed,
                      unsuppressed, suppressed)

PropInfections(cascadeData, betaBest)

```

